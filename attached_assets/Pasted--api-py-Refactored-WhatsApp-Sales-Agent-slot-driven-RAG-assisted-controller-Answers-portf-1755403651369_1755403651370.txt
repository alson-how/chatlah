# api.py
# Refactored WhatsApp Sales Agent — slot-driven + RAG-assisted controller
# - Answers portfolio first
# - Never loops the same phone prompt (cooldown + rotations)
# - Late-captures details whenever the user finally shares them
# - Uses RAG to answer off-topic questions briefly, then continues the funnel

from __future__ import annotations
from typing import Dict, Optional, Tuple
from dataclasses import dataclass, asdict
from enum import Enum, auto
import re

from fastapi import FastAPI, Request

# --- Your existing modules (adjust paths if needed) ---
# RAG retriever
from app.retriever import search  # search(query: str, top_k: int) -> [{text, meta{url,title}, distance}, ...]
# Extractors (implement these if you don't have them already)
# - extract_name(text) -> (name: Optional[str], score: int)
# - extract_phone(text) -> Optional[str]
# - parse_message(text) -> {"style_theme":..., "location":...}  (from your earlier parser)
from utils.lead import extract_name, extract_phone
from parser_my_style_location import parse_message as parse_style_location  # from earlier step
# Theme helper (optional)
from utils.theme import resolve_theme_url, mentions_theme

# ------------------------------------------------------
# Configuration
# ------------------------------------------------------

PORTFOLIO_URL = "https://jablancinteriors.com/projects/"

# Short RAG answer triggers
INFO_TRIGGERS = (
    "do you", "can you", "how", "what", "price", "cost", "timeline", "lead time",
    "revision", "portfolio", "past project", "projects", "process", "services",
    "warranty", "quotation", "quote"
)

# Rotating phone prompts (natural variation)
PHONE_PROMPTS = [
    "What’s the best phone number to reach you?",
    "Could you share a contact number so I can follow up properly?",
    "Mind sharing your phone number? I’ll WhatsApp you the next steps.",
]

# ------------------------------------------------------
# Conversation model (slots)
# ------------------------------------------------------

class Slot(Enum):
    NAME = auto()
    PHONE = auto()
    STYLE = auto()
    LOCATION = auto()
    SCOPE = auto()
    NONE = auto()

QUESTIONS: Dict[Slot, str] = {
    Slot.NAME:     "May I have your name?",
    Slot.PHONE:    "What’s the best phone number to reach you?",
    Slot.STYLE:    "What kind of style or vibe you want?",
    Slot.LOCATION: "Which area is the property located?",
    Slot.SCOPE:    "Which spaces are in scope? For example, living, kitchen, master bedroom."
}

@dataclass
class ConversationState:
    user_id: str
    lead_id: Optional[str] = None
    name: Optional[str] = None
    phone: Optional[str] = None
    style: Optional[str] = None
    location: Optional[str] = None
    scope: Optional[str] = None

    # phone ask control
    asked_phone_count: int = 0
    last_phone_prompt_turn: int = -1

    # generic control
    asked_name_phone_once: bool = False
    turn_index: int = 0  # increment each inbound message

    def next_slot(self) -> Slot:
        if not self.name:     return Slot.NAME
        if not self.phone:    return Slot.PHONE
        if not self.style:    return Slot.STYLE
        if not self.location: return Slot.LOCATION
        if not self.scope:    return Slot.SCOPE
        return Slot.NONE

    def to_dict(self): return asdict(self)

# ------------------------------------------------------
# Intent detection
# ------------------------------------------------------

PORTFOLIO_TRIGGERS = (
    "portfolio", "past project", "past projects", "projects",
    "work examples", "your work", "case study", "case studies", "references", "gallery"
)

def is_portfolio_intent(text: str) -> bool:
    t = (text or "").lower()
    return any(k in t for k in PORTFOLIO_TRIGGERS)

def is_generic_id_intent(text: str) -> bool:
    return bool(re.search(r"\b(id|interior design|renovation|makeover|concept)\b", (text or ""), re.I))

# ------------------------------------------------------
# RAG helpers
# ------------------------------------------------------

def rag_answer_one_liner(user_text: str, max_chars: int = 220) -> Optional[str]:
    """Answer side-questions briefly using RAG (1 sentence + 1 source)."""
    t = (user_text or "").lower()
    if not any(k in t for k in INFO_TRIGGERS):
        return None
    hits = search(user_text, top_k=2) or []
    if not hits:
        return None
    h = hits[0]
    url = h["meta"].get("url", "")
    snippet = (h["text"] or "").strip()
    if len(snippet) > max_chars:
        snippet = snippet[:max_chars].rsplit(" ", 1)[0] + "..."
    return f"{snippet} (Source: {url})"

def portfolio_preview(max_items: int = 3) -> Optional[str]:
    """Optional: show 1–3 project examples. Keep short to avoid WhatsApp walls of text."""
    hits = search("portfolio projects site:jablancinteriors.com", top_k=max_items) or []
    if not hits:
        return None
    items = []
    for h in hits:
        title = (h["meta"].get("title") or "").strip()
        url = h["meta"].get("url") or ""
        if title and url:
            items.append(f"{title} ({url})")
        if len(items) >= max_items:
            break
    return "Examples: " + "; ".join(items) if items else None

# ------------------------------------------------------
# Phone ask policy (cooldown + rotations)
# ------------------------------------------------------

def next_phone_prompt(state: ConversationState) -> Optional[str]:
    # Cooldown: don’t repeat within 2 turns
    if state.asked_phone_count > 0 and (state.turn_index - state.last_phone_prompt_turn) < 2:
        return None
    # Stop after 3 attempts; keep progressing other slots
    if state.asked_phone_count >= 3:
        return None
    variant = PHONE_PROMPTS[state.asked_phone_count % len(PHONE_PROMPTS)]
    if state.name:
        variant = f"Thanks, {state.name}. {variant}"
    return variant

def mark_phone_prompted(state: ConversationState):
    state.asked_phone_count += 1
    state.last_phone_prompt_turn = state.turn_index

# ------------------------------------------------------
# Follow-up question helpers (centralized, easy to extend)
# ------------------------------------------------------

def next_missing_after_portfolio(state: ConversationState) -> Optional[str]:
    if not state.style:    return QUESTIONS[Slot.STYLE]
    if not state.location: return QUESTIONS[Slot.LOCATION]
    if not state.phone:    return QUESTIONS[Slot.PHONE]
    return None

def next_non_phone_slot_question(state: ConversationState) -> Optional[str]:
    if not state.style:    return QUESTIONS[Slot.STYLE]
    if not state.location: return QUESTIONS[Slot.LOCATION]
    if not state.scope:    return QUESTIONS[Slot.SCOPE]
    return None

# ------------------------------------------------------
# Late capture (extract details from any turn)
# ------------------------------------------------------

def late_capture(user_text: str, state: ConversationState) -> None:
    # Name
    name, name_score = extract_name(user_text)
    if name and name_score >= 2 and not state.name:
        state.name = name

    # Phone
    phone = extract_phone(user_text)
    if phone and not state.phone:
        state.phone = phone

    # Style & Location
    parsed = parse_style_location(user_text)  # {"style_theme", "location", "style_link"...}
    if parsed.get("style_theme") and not state.style:
        state.style = parsed["style_theme"]
    if parsed.get("location") and not state.location:
        state.location = parsed["location"]

# ------------------------------------------------------
# Core controller: one reply per turn
# ------------------------------------------------------

REASK_PREFIX = "Just to confirm,"

def handle_turn(user_text: str, state: ConversationState) -> str:
    state.turn_index += 1

    # 0) Late-capture anything provided this turn
    late_capture(user_text, state)

    # 1) High-priority: Portfolio intent (always answer first)
    if is_portfolio_intent(user_text):
        preview = portfolio_preview()  # may be None
        head = f"Yes sure, you may look at our portfolio here {PORTFOLIO_URL}."
        body = f"\n{preview}" if preview else ""
        follow = next_missing_after_portfolio(state)
        return (head + body + (f"\n{follow}" if follow else "")).strip()

    # 2) Determine current slot
    slot = state.next_slot()

    # 3) If the user expressed generic ID intent but we’re still missing style, probe style first
    if slot in (Slot.NAME, Slot.PHONE) and is_generic_id_intent(user_text) and not state.style:
        rag_line = rag_answer_one_liner(user_text) or ""
        style_probe = "What kind of style or vibe you want?"
        return (rag_line + ("\n" if rag_line else "") + style_probe).strip()

    # 4) If the user actually answered the current slot this turn, the late-capture already stored it.
    #    Move on to the next slot question.
    new_slot = state.next_slot()
    if new_slot != slot:
        # Optional: if style was just captured, send one matching project link before next question
        if new_slot == Slot.LOCATION and mentions_theme(user_text):
            link = resolve_theme_url(user_text)
            if link:
                return f"Sure—here’s one project that fits: {link}\n{QUESTIONS[new_slot]}"
        return QUESTIONS[new_slot]

    # 5) Off-topic handling with RAG + smart phone ask policy
    rag_line = rag_answer_one_liner(user_text)
    hint = ""
    if slot == Slot.STYLE:    hint = " For example, modern minimalist, warm neutral, or industrial."
    if slot == Slot.LOCATION: hint = " For example, Mont Kiara, Bangsar, or Penang."
    if slot == Slot.SCOPE:    hint = " For example, living and kitchen."
    question = QUESTIONS[slot] + hint

    if slot == Slot.PHONE and not state.phone:
        phone_prompt = next_phone_prompt(state)
        if rag_line and phone_prompt:
            mark_phone_prompted(state)
            return f"{rag_line}\n{phone_prompt}"
        if rag_line and not phone_prompt:
            nxt = next_non_phone_slot_question(state)
            return f"{rag_line}\n{nxt}" if nxt else rag_line
        if (not rag_line) and phone_prompt:
            mark_phone_prompted(state)
            return phone_prompt
        # Cooldown active and no side-topic: progress other slots
        nxt = next_non_phone_slot_question(state)
        if nxt:
            return nxt
        # Nothing else to ask now; give a gentle nudge once per cooldown
        return "Share your contact whenever convenient and I’ll send the next steps."

    # Non-phone slots: answer side-topic briefly then re-ask
    if rag_line:
        return f"{rag_line}\n{REASK_PREFIX} {question}"
    return question

# ------------------------------------------------------
# FastAPI surface (simplified)
# ------------------------------------------------------

app = FastAPI(title="Sales Agent API (Refactored)", version="2.0.0")

# Very simple in-memory session; replace with Redis/DB in production
SESSIONS: Dict[str, ConversationState] = {}

def get_state(user_id: str) -> ConversationState:
    if user_id not in SESSIONS:
        SESSIONS[user_id] = ConversationState(user_id=user_id)
    return SESSIONS[user_id]

@app.post("/ask")
async def ask(payload: Dict):
    """
    Expected payload:
      { "user_id": "<phone_or_whatsapp_id>", "text": "<user message>" }
    """
    user_id = payload.get("user_id") or "anon"
    text = payload.get("text") or ""
    state = get_state(user_id)
    reply = handle_turn(text, state)
    return {"reply": reply, "state": state.to_dict()}

@app.get("/health")
def health():
    return {"ok": True}
